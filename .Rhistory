g+geom_line()+geom_smooth(method="lm",se=TRUE)
g <- ggplot(data=dat_all,aes(x=dat_all$dd,y=dat_all$Mean.TemperatureF))
g+geom_line()+geom_smooth(method="lm",se=TRUE)
mean(dat_all$Max.TemperatureF)
dat_all$dev <- dat_all$Max.TemperatureF - mean(dat_all$Max.TemperatureF)
g<-ggplot(dat_all,aes(x=dat_all$dd,y=dat_all$dev))
g+geom_point()
g+geom_line()
g+geom_line()+geom_smooth()
g+geom_line()+geom_smooth(method = "lm")
rm(list=ls())
library(MASS)
data("shuttle")
fit<-glm(use~wind,family="binomial",data=shuttle)
fit
fit2<-glm(use~wind+magn,family="binomial",data=shuttle)
fit2
rm(list=ls())
data("InsectSprays")
fit<-glm(count~spray,family="poisson",data=InsectSprays)
fit
rm(list=ls())
x <- -5:5
y <- c(5.12, 3.93, 2.67, 1.87, 0.52, 0.08, 0.93, 2.05, 2.54, 3.87, 4.97)
plot(x,y)
rm(list=ls())
library(MASS)
data("shuttle")
fit<-glm(use~wind,family="binomial",data=shuttle)
fit
rm(list=ls())
data("mtcars")
head(mtcars)
str(mtcars)
?mtcars
pairs(mtcars)
library(ggplot2)
ggplot(mtcars,aes(x=factor(am),y=mpg,fill=factor(am)))+geom_boxplot()+geom_point()
ggplot(mtcars,aes(x=factor(am),y=mpg,fill=factor(am)),xlab("Auto/Manual"))+geom_boxplot()+geom_point()
iauto=which(mtcars$am==0)
iman=which(mtcars$am==1)
t.test(mtcars$mpg[iman],mtcars$mpg[iauto],var.equal = FALSE,paired=FALSE)
fit <- lm(mpg~,data=mtcars)
fit <- lm(~,data=mtcars)
fit <- lm(mpg~.,data=mtcars)
fit
fit2 <- lm(mpg~am,data=mtcars)
fit2
fit
fit <- lm(mpg~Transmission,data=mtcars)
mtcars$Transmission <- as.factor(mtcars$am)
levels(mtcars$Transmission) <- c("auto","manual")
fit <- lm(mpg~Transmission,data=mtcars)
fit
summary(fit)
fit2 <- lm(mpg~.,data=mtcars)
summary(fit2)
par(mfrow=c(2,2))
plot(fit)
?anova
library(caret)
data("faithful")
set.seed(333)
rm(list=ls())
library(caret)
data("faithful")
set.seed(333)
inTrain <- createDataPartition(y=faithful$waiting,p=0.5,list=FALSE)
trainFaith <- faithful[inTrain,]
testFaith <- faithful[-inTrain,]
head(trainFaith)
library(ggplot2)
g <- ggplot(data=faithful,aes(x=faithful$waiting,y=faithful$eruptions))
g+geom_point()
g+geom_point()+geom_smooth()
g+geom_point()+geom_smooth(method="lm")
lm1 <- lm(eruptions~waiting,data=trainFaith)
summary(lm1)
g <- ggplot(data=trainFaith,aes(x=waiting,y=eruptions))
g+geom_point()+geom_smooth(method="lm")
lm1 <- lm(eruptions~waiting,data=trainFaith)
summary(lm1)
coef(lm1)
coef(lm1)[1]
lm2 <- lm(eruptions~waiting,data=testFaith)
summary(lm2)
coef(lm1)
coef(lm2)
table(coef(lm1))
table(coef(lm1),coef(lm2))
modeFit <- train(eruptions~waiting,data=trainFaith,method="lm")
modFit <- train(eruptions~waiting,data=trainFaith,method="lm")
summary(modFit$finalModel)
rm(list=ls())
library(ISLR)
library(ggplot2)
library(caret)
data(Wage)
rm(list=ls())
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
library(AppliedPredictiveModeling)
install.packages("AppliedPredictiveModeling")
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
plot(concrete$CompressiveStrength)
plot(concrete$CompressiveStrength,color=concrete$Cement)
library(ggplot2)
qplot(concrete$CompressiveStrength)
plot(concrete$CompressiveStrength)
concrete$index <- seq_len(concrete$CompressiveStrength)
seq_len(concrete$CompressiveStrength)
dim(concrete)
dim(concrete$CompressiveStrength)
View(concrete)
index<-vector(mode="numeric",length=nrow(concrete))
index
index<-1:length=nrow(concrete)
index<- (1:nrow(concrete))
index
concrete$index <- (1:nrow(concrete))
plot(concrete$index,concrete$CompressiveStrength)
qplot(concrete$CompressiveStrength,concrete$index)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$Cement)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$BlastFurnaceSlag)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$FlyAsh)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$Water)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$Superplasticizer)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$CoarseAggregate)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$FineAggregate)
qplot(concrete$index,concrete$CompressiveStrength,color=concrete$Age)
rm(list=ls())
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(1000)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
hist(training$Superplasticizer)
training$Superplasticizer
rm(list=ls())
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
names(training)
regexpr("IL",names(training))
library(stringr)
str_detect("IL",names(training))
?str_detect
str_detect(names(training),"IL")
which(str_detect(names(training),"IL"))
id<-which(str_detect(names(training),"IL"))
names(training)[id]
id<-which(str_detect(names(training),"^IL"))
names(training)[id]
rm(list=ls())
data(iris)
library(ggplot2)
names(iris)
table(iris$Species)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
library(caret)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
dim(training)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
training <- iris[inTrain,]
testing <- iris[-inTrain,]
dim(training)
dim(testing)
qplot(Petal.Width,Sepal.Width,colour=Species,data=training)
qplot(training$Sepal.Length)
modFit <- train(Species~.,method="rpart",data=training)
print(modFit$finalModel)
plot(modFit$finalModel)
plot(modFit$finalModel,uniform=TRUE,main="Classification Tree")
text(modFit$finalModel),use.n=TRUE,all=TRUE,cex=.8
text(modFit$finalModel,use.n=TRUE,all=TRUE,cex=.8
text(modFit$finalModel,use.n=TRUE,all=TRUE,cex=.8)
plot(modFit$finalModel,uniform=TRUE,main="Classification Tree")
text(modFit$finalModel,use.n=TRUE,all=TRUE,cex=.8)
library(rattle)
install.packages("rattle")
library(rattle)
library(rattle)
fancyRpartPlot(modFit$finalModel)
install.packages("rattle")
install.packages("rattle")
library(rattle)
fancyRpartPlot(modFit$finalModel)
rm(list=ls())
data(iris)
library(ggplot2)
library(caret)
names(iris)
# try to predict species from other variables
table(iris$Species)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
training <- iris[inTrain,]
testing <- iris[-inTrain,]
dim(training)
dim(testing)
# see there are 3 distinct groups
qplot(Petal.Width,Sepal.Width,colour=Species,data=training)
# build tree model w/ caret
modFit <- train(Species~.,method="rpart",data=training)
print(modFit$finalModel)
# plot the tree (as dendogram)
plot(modFit$finalModel,uniform=TRUE,main="Classification Tree")
text(modFit$finalModel,use.n=TRUE,all=TRUE,cex=.8)
# make a prettier plot w/ the rattle package
install.packages("rattle")
library(rattle)
library(rattle)
fancyRpartPlot(modFit$finalModel)
library(rattle)
fancyRpartPlot(modFit$finalModel)
fancyRpartPlot(modFit)
fancyRpartPlot(modFit$finalModel)
install.packages("rpart")
install.packages("rpart")
install.packages("rpart")
install.packages("rpart")
predict(modFit,newdata=testing)
rm(list=ls())
data(iris)
library(ggplot2)
library(caret)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
training <- iris[inTrain,]
testing <- iris[-inTrain,]
modFit <- train(Species~.,data=training,method="rf",prox=TRUE)
modFit
getTree(modFit$finalModel)
getTree(modFit$finalModel,k=2)
?classCenter
pred <- predict(modFit,testing)
# mark ones we get right
testing$predRight <- pred==testing$Species
table(pred,testing$Species)
qplot(Petal.Width,Petal.Length,colour=predRight,data=testing)
rm(list=ls())
install.packages("shiny")
rm(list=ls())
library(shiny)
install.packages("rsconnect")
install.packages("rsconnect")
install.packages("rsconnect")
install.packages("rCharts")
version
require(rCharts)
require(devtools)
install_github('ramnathv/rCharts')
install.packages("devtools")
require(devtools)
install_github('ramnathv/rCharts')
install_github('ramnathv/rCharts')
library(devtools)
install.packages("devtools")
install_github('ramnathv/rCharts')
library(devtools)
install_github('ramnathv/rCharts')
haireye=as.data.frame(HairEyeColor)
head(haireye)
n1 <- nplot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
library(rCharts)
haireye=as.data.frame(HairEyeColor)
n1 <- nplot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
library(rCharts)
n1 <- nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
haireye=as.data.frame(HairEyeColor)
n1<-nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
n1
update.packages("rCharts")
n1$save('fig.html',cdn=TRUE)
getwd()
rm(list=ls())
library(rCharts)
haireye=as.data.frame(HairEyeColor)
n1<-nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=subset(haireye,Sex=='Male'))
# save an html file
n1$save('fig.html',cdn=TRUE)
n1<-nPlot(Freq~Hair,group='Eye',type='mulitBarChart',data=haireye)
n1$save('fig.html',cdn=TRUE)
?nPlot
n1<-nPlot(Freq~Hair,group='Eye',type='multiBarChart',data=haireye)
n1$save('fig.html',cdn=TRUE)
rm(list=ls())
library(rCharts)
haireye=as.data.frame(HairEyeColor)
n1<-nPlot(Freq~Hair,group='Eye',type='multiBarChart',data=haireye)
n1
n1$save('fig.html',cdn=TRUE)
n1$save('fig.html')
n1<-nPlot(Freq~Hair,group='Eye',type='multiBarChart',data=subset(haireye,sex=='Male')
n1<-nPlot(Freq~Hair,group='Eye',type='multiBarChart',data=subset(haireye,sex=='Male'))
n1
n1$html()
n1$print()
data(economics,package="ggplot2")
data(economics,package="ggplot2")
econ <- transform(economics,data=as.character(date))
mPlot(x="date",y=c("psavert","unempmed"),type="line",data=econ)
mPlot(x="date",y=c("psavert","uempmed"),type="line",data=econ)
mPlot(x="date",y=c("psavert","uempmed"),type="line",data=econ)
econ
head(econ)
m1<-mPlot(x="date",y=c("psavert","uempmed"),type="line",data=econ)
m1
rm(list=ls())
data(economics,package="ggplot2")
econ <- transform(economics,data=as.character(date))
m1<-mPlot(x="date",y=c("psavert","uempmed"),type="line",data=econ)
m1
m1$html()
m1$render()
m1<-mPlot(x="date",y=c("psavert","uempmed"),type="Line",data=econ)
m1
library(googleVis)
M <- gvisMotionChart(Fruits)
M <- gvisMotionChart(Fruits,"Fruit","Year")
M
print(M)
print(M,'chart')
print(M,"chart")
M <- gvisMotionChart(Fruits,"Fruit","Year",options=list(width=600,height=400))
M
print(M,"chart")
Fruits
plot(M)
G <- gvisGeoChart(Exports,locationvar="Country",colorvar="Profit",options=list(width=600,height=400))
plot(G)
plot(G)
head(Exports)
G <- gvisGeoChart(Exports,locationvar="Country",colorvar="Profit",options=list(width=600,height=400),region=150)
G <- gvisGeoChart(Exports,locationvar="Country",colorvar="Profit",options=list(width=600,height=400,region=150)
G <- gvisGeoChart(Exports,locationvar="Country",colorvar="Profit",options=list(width=600,height=400,region=150))
plot(G)
G <- gvisGeoChart(Exports,locationvar="Country",colorvar="Profit",options=list(width=600,height=400,region="150"))
plot(G)
rm(list=ls())
library(manipulate)
myPlot <- function(s) {
plot(cars$dist - mean(cars$dist), cars$speed - mean(cars$speed))
abline(0, s)
}
?manipulate
manipulate(myPlot(s), s = slider(0, 2, step = 0.1))
manipulate(myPlot, s = slider(0, 2, step = 0.1))
library(devtools)
install_github("slidify","ramnathv")
install_github("slidifyLibraries/ramnathv")
install_github("slidifyLibraries","ramnathv")
library(slidify)
setwd("~/DataSciCoursera/DataProducts/project")
setwd("~/DataSciCoursera/DataProducts/slidify"
)
author("FirstProject")
slidify(index.Rmd)
slidify("index.Rmd")
browseURL("index.html")
rm(list=ls())
setwd("~/Boulder_Open_Data/")
download.file(url,"Landuse")
url <- "http://www-static.bouldercolorado.gov/docs/opendata/Landuse.zip"
download.file(url,"Landuse")
download.file(url,"Landuse.zip")
?unz
unzip("Landuse.zip")
library(rgdal)
~
landuse <- readOGR("","Landuse")
landuse <- readOGR("~","Landuse")
landuse <- readOGR("~/Boulder_Open_Data/","Landuse")
landuse <- readOGR("~/Boulder_Open_Data","Landuse")
landuse <- readOGR("/~/Boulder_Open_Data","Landuse")
landuse <- readOGR("~/Boulder_Open_Data","Landuse")
?readOGR
landuse <- readOGR(dsn="~/Boulder_Open_Data","Landuse")
landuse <- readOGR(dsn="~/Boulder_Open_Data",layer="Landuse")
landuse <- readOGR(dsn="/Users/Andy/Boulder_Open_Data",layer="Landuse",encoding=)
class(landuse)
crs(landuse)
?crs
library(raster)
?crs
crs(landuse)
extent(landuse)
landuse
landuse@data
summary(landuse)
plot(landuse)
head(landuse)
plot(landuse[1])
plot(landuse[1])
plot(landuse[1,])
plot(landuse[2,])
plot(landuse,color=LANDUSE)
plot(landuse,color=landuse$LANDUSE)
levels(landuse$LANDUSE)
warnings()
levels(landuse$LANDUSE)
nlev=length(levs)
levs <- levels(landuse$LANDUSE)
nlev=length(levs)
nlev
sub=landuse[landuse$LANDUSE=="AG"]
class(landuse)
sub=landuse[landuse$LANDUSE=="AG",]
plot(sub,color="red")
plot(sub,col="red")
plot(landuse)
plot(sub,col="red",add=TRUE)
plot(sub,add=TRUE,col="red")
table(landuse$LANDUSE)
sub=landuse[landuse$LANDUSE=="MR",]
plot(landuse)
plot(sub,add=TRUE,col="red")
plot(sub,col="red")
rm(list=ls())
library(ISLR)
library(ggplot2)
library(caret)
data(Wage)
Wage <- subset(Wage,select=-c(logwage))
# build train/test sets
inTrain <- createDataPartition(y=Wage$wage,p=0.7,list=FALSE)
training <- Wage[inTrain,]
testing <- Wage[-inTrain,]
names(Wage)
modFit <- train(wage~.,method="gbm",data=training,verbose=FALSE)
modFit <- train(wage~.,method="gbm",data=training,verbose=FALSE)
print(modfit)
print(modFit)
qplot(predict(modFit,testing),wage,data=testing)
# Model based prediction
rm(list=ls())
library(ggplot2)
names(iris)
table(iris$Species)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
testing <- iris[-inTrain,]
modla <- train(Species~.,training,method="lda")
# naive bayes
modnb <- train(Species~.,training,method="nb")
plda <- predict(modla,testing)
pnb <- predict(modnb,tesing)
modla <- train(Species~.,training,method="lda")
# naive bayes
modnb <- train(Species~.,training,method="nb")
modla <- train(Species~.,data=training,method="lda")
# naive bayes
modnb <- train(Species~.,data=training,method="nb")
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
training <- iris[inTrain,]
testing <- iris[-inTrain,]
# linear disc. analysis
modla <- train(Species~.,data=training,method="lda")
# naive bayes
modnb <- train(Species~.,data=training,method="nb")
plda <- predict(modla,testing)
pnb <- predict(modnb,tesing)
table(plda,pnb)
pnb <- predict(modnb,testing)
table(plda,pnb)
equalpred <- (pla==pnb)
equalpred <- (plda==pnb)
qplot(Petal.Width,Sepal.Width,colour=equalpred,data=testing)
rm(list=ls())
library(ggplot2)
names(iris)
table(iris$Species)
inTrain <- createDataPartition(y=iris$Species,p=0.7,list=FALSE)
training <- iris[inTrain,]
testing <- iris[-inTrain,]
# linear disc. analysis
modla <- train(Species~.,data=training,method="lda")
# naive bayes
modnb <- train(Species~.,data=training,method="nb")
plda <- predict(modla,testing)
pnb <- predict(modnb,testing)
table(plda,pnb)
equalpred <- (plda==pnb)
qplot(Petal.Width,Sepal.Width,colour=equalpred,data=testing)
rm(list=ls())
library(AppliedPredictiveModeling)
data(segmentationOriginal)
library(caret)
segment
segmentationOriginal
names(segmentationOriginal)
inTrain <- createDataPartition(y=segmentationOriginal$Case,p=0.5,list=FALSE)
training <- segmentationOriginal[inTrain,]
testing <- segmentationOriginal[-inTrain,]
set.seed(125)
